<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>CoulombHO2D: Notes</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">CoulombHO2D
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('md_notes.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Notes </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Here are some notes regarding the optimizations in this code.</p>
<h2>Foreword </h2>
<p>All mentions of "speed" here refer to the inverse time taken, so a 33% improvement implies that the time is reduced by 25%.</p>
<p>There are two kinds of test cases:</p>
<ul>
<li><code>(kmax, kfmi, omega)</code>: This is done in the Hartree-Fock program as part of its matrix loading procedure. Not as clean of an environment to test in, but it is more realistic. <code>kmax</code> is the number of shells in the basis, <code>kfmi</code> is the number of occupied shells (shouldn't have any significant effect, although it may change the order in which matrix elements are computed), and <code>omega</code> is the frequency (minor effect, as it simply multiplies the matrix by a scalar).</li>
<li><code>(n_max, ml_max)</code>: This is done by the <code>profile(n_max, ml_max)</code> procedure in <code>test/coulomb_ho2d.cpp</code>. This calculates matrix elements for all <code>n &lt; n_max</code> and <code>|ml| &lt; 5</code>. When there is a <code>xN</code> present, it means the test was repeated <code>N</code> times. Note that tests are often done consecutively in one process, so the cache is never cleared in between the adjacent runs.</li>
</ul>
<p>All test cases are done with <code>-O3 -ffast-math</code>, using either Clang or GCC (where such records exist).</p>
<h2>Some statistics </h2>
<p>Original method: </p><pre class="fragment">(2, 3):    36.5 us / element
(3, 3):   344.2 us / element
(3, 6): 1.840   ms / element
(4, 2): 1.101   ms / element
</pre><p>New method: </p><pre class="fragment">(2, 3):    0.71 us / element
(3, 3):    3.2  us / element
(3, 6):    6.10 us / element
(4, 2):    8.20 us / element
</pre><p>Here are some older benchmarks. Original method: </p><pre class="fragment">(4, 4): 354     s (for all  87808 elements)
</pre><p>"Semi-new" method (one of the previous versions): </p><pre class="fragment">(4, 4):  45     s (for all  87808 elements)
(5, 5): 975     s (for all 455625 elements)
</pre><p>New method: </p><pre class="fragment">(4, 4):   1.159 s (for all  87808 elements)
(5, 5):  20.44  s (for all 455625 elements)
</pre><p>The <code>(4, 4)</code> matrix is about 60-70% dense (i.e. nonzero elements) after excluding the elements that don't conserve <code>ml</code>. In general, the density decreases as one increases the size of the basis. (Note: this is measured using an unphysical basis, since normally one does not truncate using <code>n</code> and <code>|ml|</code> independently, but using <code>E = 2 * n + |ml| + 1</code> instead).</p>
<h2>Optimization log </h2>
<p>Note that this is not a comprehensive or completely accurate account of the optimizations in this code. The information here is roughly chronological.</p>
<h3>Copying matrix elements using hermitivity</h3>
<p>Not really an optimization of the matrix element calculation, but more relevant for the user. Minimizing the number of calls to <code>coulomb_ho2d</code> is a good thing: using hermitivity one can decrease that by about 50%.</p>
<h4>Test case: <code>(kmax = 8, kfmi = 7, omega = 1)</code></h4>
<p>Indeed, this provided a 100% speed increase.</p>
<h3>Using the builtin <code>lgamma</code> for <code>LogFac</code></h3>
<p>Changed algorithm from logarithmic summation: </p><pre class="fragment">double temp = 0;
for (int i = 2; i &lt; n + 1; i++)
    temp += log((double) i);
return temp;
</pre><p>to the builtin <code>lgamma</code> function (requires C99 / C++11).</p>
<h4>Test case: <code>(kmax = 6, kfmi = 5, omega = 1)</code></h4>
<p>This provides a moderate (25%) increase in speed. Theoretically, it is expected to provide higher gains in larger bases but no tests have been done to verify this.</p>
<h3>Memoization of <code>LogFac</code></h3>
<p><code>LogFac</code> is a major bottleneck in the calculation and there optimization of this function is quite critical for fast calculation of matrix elements. <code>LogFac</code> is called on predominantly a very small set of natural numbers, so it helps to cache the results in an array instead of computing them every time.</p>
<p>One could also do this with a <code>switch</code> statement, but this suffers from scalability issues:</p>
<ul>
<li>It's not clear how to extend this to larger bases since the number of branches will have to increase but <code>switch</code> statements are essentially static (implementing this dynamically is difficult and non-portable).</li>
<li>The performance benefit likely diminishes as the number of branches grows, and eventually may become a pessimization due to the size of the code. <code>LogFac</code> is expected to be inlined at various places, so the growth in the size of the code can impact on the instruction caching.</li>
<li>Does not mix with the dynamic</li>
</ul>
<p>Therefore, for simplicity, the memoization is implemented using a simple array where the results are cached. It is expected that the array should be small and used frequently enough that it can fit within a very fast cache.</p>
<p>This provides a significant gain (100% to 200%) in speed.</p>
<h3>Handling cache misses</h3>
<p>Note: this is referring to misses in the memoization array, not the CPU's.</p>
<p>If the result hasn't been cached yet, it needs to calculate the results. This part can be rather complicated as it involves memory allocation (it doesn't know how large the cache would be ahead of time). Fortunately this is a very rare event, and should not significantly impact branch prediction.</p>
<p>Most of the time, the CPU should expect to read the value directly from the memoization array. This is a relatively simply process and should be inlined.</p>
<p>In contrast, the process of growing the cache is generally slow and complicated, and it is a pessimization to inline this part of the code. Therefore a <code>noinline</code> directive is used to prevent this from occurring.</p>
<p>In theory, a branch prediction hint may help (using <code>__builtin_expect</code>) but this does not seem to be the case in practice.</p>
<h4>Test case: <code>(n_max = 3, ml_max = 6)</code></h4>
<p>The use of <code>noinline</code> had little impact on GCC (probably because GCC decided to not inline it anyway), but for clang using <code>noinline</code> provided a 20% increase in speed (in the test case, at least).</p>
<ul>
<li>In Clang:<ul>
<li>With <code>noinline</code> turned on, the time was 25.1 sec.</li>
<li>With <code>noinline</code> turned off, the time was 30.2 sec.<ul>
<li>A correct branch hint increased time by 0.4 sec.</li>
<li>An incorrect branch hint increased time by 0.9 sec.</li>
</ul>
</li>
</ul>
</li>
<li>In GCC:<ul>
<li>With <code>noinline</code> either on or off, the time was 26.9 sec. (Slightly slower than Clang in the best-case scenario.)<ul>
<li>A correct branch hint made no difference here (probably deduced by GCC).</li>
<li>An incorrect branch hint increased time by 0.9 sec.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3>Memoization of <code>lgamma2</code></h3>
<p>Turns out that although there are two <code>lgamma</code> calls, the input is always an integer or half-integer, so the results can also be memoized. This is done using the same trick as before, but the key question is: can these two caches be combined? (Since <code>lgamma</code> and <code>LogFac2</code> are related, this means a cache for <code>lgamma</code> for all half-integers is sufficient for <code>LogFac</code>.)</p>
<p>However, the downside is: forcing <code>LogFac</code> (note: this is now called <code>lfac</code> as of writing) to use <code>lgamma</code>'s cache involves performing a small operation, so this adds a tiny amount of overhead. Furthermore, <code>LogFac</code> is used more frequently than <code>lgamma</code>.</p>
<h4>Test cases: (2, 3) x40, (3, 3) x10, (3, 4) x2</h4>
<p>Turns out that there is a small difference of about 2% (after several measurements). That is, using two caches provides a very small speed increase, at the expensive of managing another cache (and some redundant data).</p>
<h3>Precomputing <code>lgamma2</code> &amp; <code>pow2</code></h3>
<p>It turns out that for a given set of quantum numbers, <code>lgamma2</code> and <code>pow2</code> have a finite domain that can be calculated ahead of time, so it is possible to simply precompute all the necessary results of these two functions ahead of time. This allows the evaluation of these function to be much simpler: the size comparison plus potential branching can be entirely eliminated.</p>
<p>This involved a fairly major rewrite however. In part, this was done to address the concerns about thread-safety: these functions are not safe when called from different threads due to the use of global data.</p>
<h4>Test cases: (2, 3) x40, (3, 3) x10, (3, 6) x2, (4, 2) x2</h4>
<p>The benefit varies (was lowest for <code>(3, 6)</code> and highest for <code>(2, 3)</code>), but it was significant nonetheless: about 25% to 60% increase in speed.</p>
<h3>Avoiding divisions</h3>
<p>Division can be slower than multiplication, so as many divisions were converted into multiplications as possible. Furthermore, the inner loop (after factoring out some terms) consists of solely division, so the <code>fac</code> and <code>tgamma2</code> functions were converted into their reciprocals instead.</p>
<h4>Test cases: (2, 3) x40, (3, 3) x10, (3, 6) x2, (4, 2) x2</h4>
<p>A fair amount of variation in improvement: about 20% to 50% increase in speed. The benefit was least for <code>(2, 3)</code> and highest for <code>(3, 6)</code>.</p>
<h3>Converting factorial ratios into a running binomial coefficient</h3>
<p>There is a very simple way of calculating the binomial coefficient as a running sum: </p><pre class="fragment">n / 1 * (n - 1) / 2 * (n - 2) / 3 * (n - 3) / 4 * ... * (n - k + 1) / k
</pre><p>This means it's possible to avoid the factorial ratios by computing this cumulative product. However, after further testing this turned out to be more of a pessimization. Not unexpected, since the factorials were precomputed. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Wed Feb 4 2015 22:06:30 for CoulombHO2D by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.9.1 </li>
  </ul>
</div>
</body>
</html>
