#!/bin/sh
set -e

# create and initialize the documentation directory
#
#   - 1:  directory of the documentation
#
doc_init() {
    if [ $# -ne 1 ]
    then
        echo >&2 'doc_upload_init: expected 1 argument'
        return 1
    fi
    [ -d "$1/.git" ] || (
        mkdir -p "$1"
        url=`git remote -v | grep origin | awk '{ printf "%s", $2; exit }'`
        cd "$1"
        git init
        git config user.name Bot
        git config user.email "<>"
        git commit -m _ --allow-empty
        git remote add origin "$url"
    )
}

# upload documentation to the remote server
#
#   - 1:  directory of the documentation
#
doc_upload() {
    if [ $# -ne 1 ]
    then
        echo >&2 'doc_upload: expected 1 argument'
        return 1
    fi
    cd "$1"
    git add -A
    git commit --amend -q -m Autogenerated
    git push -f origin master:gh-pages
}

# perform a one-sided exponential search to find the
# largest value at which the trial function succeeds
#
# inputs:
#   - 1:    initial value, which must be a power of 2
#           and defines the smallest possible value
#   - try:  trial function that accepts one parameter
#
# output:
#   - ret:  threshold before which the try function fails
#
exp_search() {

    # find a strict upper bound
    _1=$1
    _3=$_1
    _2=$_1
    while try "$_1"
    do
        _3=$_2
        _2=$_1
        _1=`expr "$_1" + "$_2"`
    done

    # not strictly needed, but this optimizes for the special case where the
    # boundary lies on powers of 2 at expense of more general cases
    _1=`expr "$_2" + 1`
    try "$_1" || {
        ret=$_2
        return
    }

    # use binary search to refine the exact boundary
    _1=$_2
    _2=$_3
    _3=$_1
    _1=`expr "$_1" + "$_2"`
    while :
    do
        _2=`expr "$_2" / 2`
        if try "$_1"
        then
            _3=$_1
            _1=`expr "$_1" + "$_2"`
        else
            _1=`expr "$_3" + "$_2"`
        fi
        if [ "$_2" -eq 1 ]
        then
            break
        fi
    done
    if try "$_1"
    then
        ret=$_1
    else
        ret=$_3
    fi
}

# detect_limits SIGNEDNESS TYPE_NAME MACRO_PREFIX [HEADER...]
detect_limits() {
    # hopefully we won't reach this any time soon?
    max_bits=32768

    # grab arguments
    if [ $# -lt 3 ]
    then
        printf >&2 'need at least 3 arguments\n'
        return 1
    fi
    signed=$1
    shift
    itype=$1
    shift
    macro=$1
    shift
    case $signed in
         signed)   signed=t;;
         unsigned) signed=;;
         *)        printf >&2 'invalid signedness: %s\n' "$signed"
                   return 1;;
    esac

    # find the number of non-padding bits
    includes=`for header
    do
        printf '#include <%s>\n' "$header"
    done`
    failed=
    try() {
        if [ "$1" -gt "$max_bits" ]
        then
            printf >&2 "gave up trying to detect limits of '%s'\n" "$itype"
            printf >&2 "are you from the 22nd century??\n"
            failed=t
            return 1
        fi
        msg=`printf '%s\nstruct dummy { %s dummy : %s; };\n' \
            "$includes" "$itype" "$1" |
            cc 2>&1 -x c -o /dev/null -c -`
    }
    exp_search 4
    if [ "$failed" ]
    then
        exit 1
    fi
    if [ "$ret" -lt 8 ]
    then
        printf >&2 "couldn't detect the limits of '%s' " "$itype"
        printf >&2 "due to unknown compiler error:\n%s" "$msg"
        return 1
    fi

    # compute the maximum value by repeating 'f' up to `value_bits / 4` times
    # and then prepending the remainder
    if [ "$signed" ]
    then
        ret=`expr "$ret" - 1`
    fi
    max=`expr "$ret" / 4`
    max=`dd </dev/zero 2>/dev/null bs=1 count="$max" | tr '\0' f`
    case `expr "$ret" '%' 4` in
        0) max=0x$max;;
        1) max=0x1$max;;
        2) max=0x3$max;;
        3) max=0x7$max;;
    esac

    # generate header file
    printf '%s\n#define %s_MAX ((%s) %s)\n' \
           "$includes" "$macro" "$itype" "$max"
    if [ "$signed" ]
    then
        printf '#define %s_MIN (-%s_MAX - ((%s)' "$macro" "$macro" "$itype"
        printf ' 1 & (%s) -1 && ((%s) 3 &' "$itype" "$itype"
        printf ' (%s) -1) != (%s) 1))\n'  "$itype" "$itype"
    fi
}
